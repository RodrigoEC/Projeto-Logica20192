MODULE main
    VAR
        deviceCapacity: 0..1000;
        appStatus: {uninstalled, installed};
        attStatus: {updated, outdated};
        creditsAcc: 0..500;
        priceApp: 0..500;
        appSize: 0..1000;
        association: boolean;
        p1 : process appStore(deviceCapacity, appStatus, creditsAcc, priceApp, appSize, attStatus, association);

    ASSIGN
        init(deviceCapacity) := 1000;
        init(appStatus) := {uninstalled};
        init(attStatus) := {outdated};
	    init(creditsAcc) := 500;
        init(priceApp) := 100;
        init(appSize) :=  200;
        init(association) := FALSE;

    -- Verifica que nunca existe um estado em que o appStatus é diferente de uninstalled e a associação é falsa
    SPEC AG !(appStatus != uninstalled & association = FALSE)
    -- Verifica que se o appStatus = installed então futuramente o appStatus sera uninstaled
    SPEC AF (appStatus = installed -> appStatus = uninstalled)
    -- Verifica que dado um preço do app menor ou igual aos creditos da conta e appStatus = uninstalled, em algum momento no futuro o estado é installed
    LTLSPEC F (priceApp <= creditsAcc & appSize <= deviceCapacity & appStatus = uninstalled -> X (appStatus = installed))

    -- Verifica que dado um estado de appStatus = uninstalled, se priceApp > credtAcc ou appSize > deviceCapacity então o appStatus permance uninstalled
    LTLSPEC G (appStatus = uninstalled & (priceApp > creditsAcc | appSize > deviceCapacity) -> X(appStatus = uninstalled))

MODULE appStore(deviceCapacity, appStatus, creditsAcc, priceApp, appSize, attStatus, association)
    ASSIGN
        next(appStatus) :=
                    case
                         -- Intalar app desinstalado
                        (priceApp = 0) & (appStatus = uninstalled) & (appSize <= deviceCapacity): {installed};
                        (priceApp = 0) & (appStatus = uninstalled) & (appSize > deviceCapacity): {uninstalled};
                        (priceApp > 0) & (creditsAcc >= priceApp) & (appStatus = uninstalled) & (appSize <= deviceCapacity): {installed};
                        (priceApp > 0) & (creditsAcc < priceApp) & (appStatus = uninstalled) & (appSize <= deviceCapacity): {uninstalled};
                        (priceApp > 0) & (creditsAcc >= priceApp) & (appStatus = uninstalled) & (appSize > deviceCapacity): {uninstalled};
                        (priceApp > 0) & (creditsAcc < priceApp) & (appStatus = uninstalled) & (appSize > deviceCapacity): {uninstalled};
                        
                        -- Instalar app instalado
                        (priceApp = 0) & (appStatus = installed) & (appSize <= deviceCapacity): {installed};
                        (priceApp = 0) & (appStatus = installed) & (appSize > deviceCapacity): {installed};
                        (priceApp > 0) & (creditsAcc >= priceApp) & (appStatus = installed) & (appSize <= deviceCapacity): {installed};
                        (priceApp > 0) & (creditsAcc < priceApp) & (appStatus = installed) & (appSize <= deviceCapacity): {installed};
                        (priceApp > 0) & (creditsAcc >= priceApp) & (appStatus = installed) & (appSize > deviceCapacity): {installed};
                        (priceApp > 0) & (creditsAcc < priceApp) & (appStatus = installed) & (appSize > deviceCapacity): {installed};

                        --Desinstalar app instalado
                        (appStatus = installed): {uninstalled};
                    esac;
        -- Atualizando associação de um app
        next(association) :=
                    case
                        (appStatus != uninstalled): TRUE;
                        TRUE: association;  
                    esac;
    FAIRNESS
        running

-- Isso aqui foi uma definições de umas parada que possivelmente eu usarei futuramente
-- AF prepo -> Propoe que a condição sempre vai ser TRUE, no futuro.
-- AG prepo -> Propoe que a condição seja sempre verdade em todos os estados.
-- AX prepo -> Propoe que a condição seja alcançada no proximo estado.

-- F prepo -> Propoe que a condição vai ser TRUE, no futuro.
-- G prepo -> Propoe que a condição seja verdade em todos os estados.
-- X prepo -> Propoe que a condição seja alcançada no proximo estado.